Day 1 
============================
intro to the game assignment, and physics module.

We are making our physics engine this week
but it's not rigid bodies, or angular momentum 

we will more be talking about architecture and collisions

user interaction
	then game logic

	then physics engine update
		positional logic
		collision detection
		collision resolution

hand all that back to renderer
render

the monkey engine
	start main loop
	has an editor update separate from play update

	if sumulate true
		run physics update
then render


the spline engine

main engine loop start
	if playing == false
		editor update
		editor physics update

	if playing == true
		game update
			game systems
				can fetch the list of collisions from the physics engine 
		physics update
			collision detection
			collision resolution
	
	then hand off to renderer


	collisions should not just return a bool but a struct of relevant data about the collision

	collision response after the collision detection
		elaborate physics responses is out of scope for this project unless you are implementing a third party engine

	CheckIntersections()	returns a vector of collisions

	enum is better than dynamic class for checking collider types at runtime

	we should start with sphere to sphere collisions


	struct CollisionEvent
		entity a
		entity b

	class PhysicsSystem
		public:
		void UpdatePhysics(Scene);
		void DrawDebugColliders();

		static bool CheckIntersect(collider a, collider b);

		const std::vector<CollisionEvent& GetcollisionEvents() const;

		void ClearEvents(); // clears the collisionEvents vector

		private:
		vector<CollisionEvent> m_collisionEvents;
		float m_CurrentTime;
		float m_TotalTime;
		float m_HoizontalMovement;

TODAY'S TASK
	SET UP PHYSICS SYSTEM CLASS AND START ON SPHERE TO SPHERE COLLISIONS
============================
Day 2
============================
Oriented Bounding Boxes

	BoxCollider
		Mat4 transform
		vec3 offset
		vec3 extents

example of sphere and box collision
	get sphere position in the box's local space. this allows us to treat the box as an AABB (axis aligned bounding box)

example of box to box intersection detection
	see slides for details

went over the separating axis theorem
	Two convex shapes do not collide if and only if there exists an axis along which their projections do not overlap.

	dot product of the point to the axis results in the length of that projection on the axis.
============================
Day 3
============================

ray casts and raycast to aabb

we will use a thing called the "slab" technique
	if the biggest entry point offset by the extents of a box of any axis along the ray is smaller than the smallest exit point offset by the extents of a box on any axis along the ray. 
		with the exceptions
			when rhe ray does not have an entry or exit point along the ray.
			when  smallest exit point is negative
			if the origin of the ray is insice to box we automatically have an intersection

should be cheaper than separating axis theorem collisions

Position = start + (distance * direction);

online theorems call distance t for time

check each axis 
position.x = start.x + (distance * direction.x)
x(t) = o.x + (t * d.x);

translate the box into an aabb by moving the ray into the box's object space
	this allows us to disregard the position of the box and only use its extents

we know the start and end extents of the box on the axis, so we can solve for distance/time of the ray intersecting those points
Distance1 = (xmax - start.x)/ direction.x
Distance2 = (xmin - start.x)/ direction.x

the smallest of the two distances is when our ray enters the slab, and the larger is when it enters the slab
test all three axis of the aabb
gather and compare the entry and exit points to look for overlaps

============================
Final Module - THE GAME
============================

DAY 1

engine / game tours of Martin Andersson and Oscar Kamf (the teachers) work

Tomorrow some more ECS and playmode stuff with Martin
wednesday terrain from image generation
next week catmul spline